{"task_id": "HumanEval/0", "prompt": "// Return true if any two numbers in the array are closer than the given threshold.\nfn has_close_elements(numbers: array<float>, threshold: float) -> bool {", "canonical_solution": "fn has_close_elements(numbers: array<float>, threshold: float) -> bool {\n    let i = 0;\n    while i < len(numbers) {\n        let j = i + 1;\n        while j < len(numbers) {\n            if abs(numbers[i] - numbers[j]) < threshold {\n                return true;\n            }\n            set j = j + 1;\n        }\n        set i = i + 1;\n    }\n    return false;\n}", "test": "test \"has_close_elements\" {\n    assert(has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3));\n    assert(!has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05));\n    assert(has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95));\n    assert(!has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8));\n    assert(has_close_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1));\n}", "entry_point": "has_close_elements"}
{"task_id": "HumanEval/2", "prompt": "// Given a positive float, return its decimal part.\n// truncate_number(3.5) => 0.5\nfn truncate_number(number: float) -> float {", "canonical_solution": "fn truncate_number(number: float) -> float {\n    return number - floor(number);\n}", "test": "test \"truncate_number\" {\n    assert(truncate_number(3.5) == 0.5);\n    assert(truncate_number(1.25) == 0.25);\n    assert(truncate_number(123.0) == 0.0);\n}", "entry_point": "truncate_number"}
{"task_id": "HumanEval/4", "prompt": "// For a given array of ints, return the mean absolute deviation around the mean.\nfn mean_absolute_deviation(numbers: array<int>) -> float {", "canonical_solution": "fn mean_absolute_deviation(numbers: array<int>) -> float {\n    let mean = sum(numbers) / len(numbers);\n    let abs_sum = 0;\n    for n in numbers {\n        set abs_sum = abs_sum + abs(n - mean);\n    }\n    return abs_sum / len(numbers);\n}", "test": "test \"mean_absolute_deviation\" {\n    assert(mean_absolute_deviation([1, 2, 3]) == 0);\n    assert(mean_absolute_deviation([1, 2, 3, 4]) == 1);\n    assert(mean_absolute_deviation([1, 2, 3, 4, 5]) == 1);\n}", "entry_point": "mean_absolute_deviation"}
{"task_id": "HumanEval/7", "prompt": "// Filter an input array of strings only for ones that contain the given substring.\nfn filter_by_substring(strings: array<string>, sub: string) -> array<string> {", "canonical_solution": "fn filter_by_substring(strings: array<string>, sub: string) -> array<string> {\n    let result: array<string> = [];\n    for s in strings {\n        if contains(s, sub) {\n            set result = append(result, s);\n        }\n    }\n    return result;\n}", "test": "test \"filter_by_substring\" {\n    assert_eq(filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\"), [\"abc\", \"bacd\", \"array\"]);\n    assert_eq(filter_by_substring([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\"), [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert_eq(len(filter_by_substring([], \"a\")), 0);\n}", "entry_point": "filter_by_substring"}
{"task_id": "HumanEval/8", "prompt": "// Return a tuple of (sum, product) for an array of ints.\n// For an empty array, return (0, 1).\nfn sum_product(numbers: array<int>) -> (int, int) {", "canonical_solution": "fn sum_product(numbers: array<int>) -> (int, int) {\n    let s = sum(numbers);\n    let p = 1;\n    for n in numbers {\n        set p = p * n;\n    }\n    return (s, p);\n}", "test": "test \"sum_product\" {\n    assert_eq(sum_product([]), (0, 1));\n    assert_eq(sum_product([1, 2, 3, 4]), (10, 24));\n    assert_eq(sum_product([1, 1, 1]), (3, 1));\n}", "entry_point": "sum_product"}
{"task_id": "HumanEval/9", "prompt": "// From an array of ints, return the running maximum at each position.\n// rolling_max([1, 2, 3, 2, 3, 4, 2]) => [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: array<int>) -> array<int> {", "canonical_solution": "fn rolling_max(numbers: array<int>) -> array<int> {\n    let result: array<int> = [];\n    let current = numbers[0];\n    for n in numbers {\n        set current = max(current, n);\n        set result = append(result, current);\n    }\n    return result;\n}", "test": "test \"rolling_max\" {\n    assert_eq(rolling_max([1, 2, 3, 2, 3, 4, 2]), [1, 2, 3, 3, 3, 4, 4]);\n    assert_eq(rolling_max([5, 4, 3, 2, 1]), [5, 5, 5, 5, 5]);\n    assert_eq(rolling_max([1, 1, 1]), [1, 1, 1]);\n}", "entry_point": "rolling_max"}
{"task_id": "HumanEval/13", "prompt": "// Return the greatest common divisor of two integers.\nfn greatest_common_divisor(a: int, b: int) -> int {", "canonical_solution": "fn greatest_common_divisor(a: int, b: int) -> int {\n    let x = a;\n    let y = b;\n    while y != 0 {\n        let temp = y;\n        set y = x % y;\n        set x = temp;\n    }\n    return x;\n}", "test": "test \"greatest_common_divisor\" {\n    assert_eq(greatest_common_divisor(3, 5), 1);\n    assert_eq(greatest_common_divisor(25, 15), 5);\n    assert_eq(greatest_common_divisor(12, 8), 4);\n    assert_eq(greatest_common_divisor(49, 14), 7);\n}", "entry_point": "greatest_common_divisor"}
{"task_id": "HumanEval/15", "prompt": "// Return a string containing space-delimited numbers from 0 to n inclusive.\nfn string_sequence(n: int) -> string {", "canonical_solution": "fn string_sequence(n: int) -> string {\n    let parts: array<string> = [];\n    let i = 0;\n    while i <= n {\n        set parts = append(parts, to_string(i));\n        set i = i + 1;\n    }\n    return join(parts, \" \");\n}", "test": "test \"string_sequence\" {\n    assert_eq(string_sequence(0), \"0\");\n    assert_eq(string_sequence(5), \"0 1 2 3 4 5\");\n    assert_eq(string_sequence(3), \"0 1 2 3\");\n}", "entry_point": "string_sequence"}
{"task_id": "HumanEval/28", "prompt": "// Concatenate an array of strings into a single string.\nfn concatenate(strings: array<string>) -> string {", "canonical_solution": "fn concatenate(strings: array<string>) -> string {\n    return join(strings, \"\");\n}", "test": "test \"concatenate\" {\n    assert_eq(concatenate([]), \"\");\n    assert_eq(concatenate([\"a\", \"b\", \"c\"]), \"abc\");\n    assert_eq(concatenate([\"x\", \"y\", \"z\"]), \"xyz\");\n}", "entry_point": "concatenate"}
{"task_id": "HumanEval/31", "prompt": "// Return true if the number is prime.\nfn is_prime(n: int) -> bool {", "canonical_solution": "fn is_prime(n: int) -> bool {\n    if n < 2 {\n        return false;\n    }\n    let i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n            return false;\n        }\n        set i = i + 1;\n    }\n    return true;\n}", "test": "test \"is_prime\" {\n    assert(!is_prime(0));\n    assert(!is_prime(1));\n    assert(is_prime(2));\n    assert(is_prime(3));\n    assert(!is_prime(4));\n    assert(is_prime(5));\n    assert(is_prime(11));\n    assert(is_prime(101));\n    assert(!is_prime(100));\n}", "entry_point": "is_prime"}
{"task_id": "HumanEval/33", "prompt": "// Sort an array of ints in ascending order and remove duplicates.\nfn sort_unique(arr: array<int>) -> array<int> {", "canonical_solution": "fn sort_unique(arr: array<int>) -> array<int> {\n    let sorted = sort(arr);\n    let result: array<int> = [];\n    for val in sorted {\n        if len(result) == 0 {\n            set result = append(result, val);\n        } else if result[len(result) - 1] != val {\n            set result = append(result, val);\n        }\n    }\n    return result;\n}", "test": "test \"sort_unique\" {\n    assert_eq(sort_unique([5, 3, 5, 2, 3, 3, 9, 0, 123]), [0, 2, 3, 5, 9, 123]);\n    assert_eq(sort_unique([1, 1, 1]), [1]);\n    assert_eq(sort_unique([]), []);\n}", "entry_point": "sort_unique"}
{"task_id": "HumanEval/36", "prompt": "// Return the number of times the digit 7 appears in integers less than n\n// that are divisible by 11 or 13.\nfn fizz_buzz(n: int) -> int {", "canonical_solution": "fn fizz_buzz(n: int) -> int {\n    let total = 0;\n    let i = 0;\n    while i < n {\n        if i % 11 == 0 {\n            set total = total + count(to_string(i), \"7\");\n        } else if i % 13 == 0 {\n            set total = total + count(to_string(i), \"7\");\n        }\n        set i = i + 1;\n    }\n    return total;\n}", "test": "test \"fizz_buzz\" {\n    assert_eq(fizz_buzz(50), 0);\n    assert_eq(fizz_buzz(78), 2);\n    assert_eq(fizz_buzz(79), 3);\n}", "entry_point": "fizz_buzz"}
{"task_id": "HumanEval/48", "prompt": "// Check if a given string is a palindrome.\nfn is_palindrome(text: string) -> bool {", "canonical_solution": "fn is_palindrome(text: string) -> bool {\n    return text == reverse(text);\n}", "test": "test \"is_palindrome\" {\n    assert(is_palindrome(\"\"));\n    assert(is_palindrome(\"aba\"));\n    assert(is_palindrome(\"racecar\"));\n    assert(!is_palindrome(\"hello\"));\n    assert(is_palindrome(\"a\"));\n}", "entry_point": "is_palindrome"}
{"task_id": "HumanEval/54", "prompt": "// Check if two strings are the same ignoring case.\nfn same_chars_ignore_case(s0: string, s1: string) -> bool {", "canonical_solution": "fn same_chars_ignore_case(s0: string, s1: string) -> bool {\n    return to_lower(s0) == to_lower(s1);\n}", "test": "test \"same_chars_ignore_case\" {\n    assert(same_chars_ignore_case(\"Hello\", \"hello\"));\n    assert(same_chars_ignore_case(\"ABC\", \"abc\"));\n    assert(!same_chars_ignore_case(\"abc\", \"def\"));\n    assert(same_chars_ignore_case(\"\", \"\"));\n}", "entry_point": "same_chars_ignore_case"}
{"task_id": "HumanEval/66", "prompt": "// Given a string of digits, return the sum of those digits.\n// digitSum(\"12345\") => 15\nfn digit_sum_str(s: string) -> int {", "canonical_solution": "fn digit_sum_str(s: string) -> int {\n    let total = 0;\n    let i = 0;\n    while i < len(s) {\n        let ch = char_at(s, i);\n        if is_digit(ch) {\n            set total = total + char_code(ch) - char_code(\"0\");\n        }\n        set i = i + 1;\n    }\n    return total;\n}", "test": "test \"digit_sum_str\" {\n    assert_eq(digit_sum_str(\"12345\"), 15);\n    assert_eq(digit_sum_str(\"0\"), 0);\n    assert_eq(digit_sum_str(\"999\"), 27);\n    assert_eq(digit_sum_str(\"\"), 0);\n}", "entry_point": "digit_sum_str"}
