pub fn count_digits_recursive(n: int) -> int {
    let num = n;
    if num < 0 {
        set num = -num;
    }
    if num <= 9 {
        return 1;
    }
    return 1 + count_digits_recursive(num / 10);
}

pub fn count_digits_iterative(n: int) -> int {
    if n == 0 {
        return 1;
    }
    let num = n;
    if num < 0 {
        set num = -num;
    }
    let count = 0;
    while num != 0 {
        set num = num / 10;
        set count = count + 1;
    }
    return count;
}

pub fn analyze_number(n: int) -> map<string, int> {
    let is_negative = if n < 0 {
        1
    } else {
        0
    };
    let is_even = if n % 2 == 0 {
        1
    } else {
        0
    };
    
    return map {
        "original_number": n,
        "digit_count_recursive": count_digits_recursive(n),
        "digit_count_iterative": count_digits_iterative(n),
        "is_negative": is_negative,
        "is_even": is_even,
    };
}

test "analyze positive" {
    let res = analyze_number(156);
    assert(res["original_number"] == 156);
    assert(res["digit_count_recursive"] == 3);
    assert(res["digit_count_iterative"] == 3);
    assert(res["is_negative"] == 0);
    assert(res["is_even"] == 1);
}

test "analyze negative" {
    let res = analyze_number(-7);
    assert(res["original_number"] == -7);
    assert(res["digit_count_recursive"] == 1);
    assert(res["digit_count_iterative"] == 1);
    assert(res["is_negative"] == 1);
    assert(res["is_even"] == 0);
}
